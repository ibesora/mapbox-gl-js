<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mapbox test</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<div id="map"></div>
<script type="module">
  import { kml } from "https://unpkg.com/@tmcw/togeojson?module";

    mapboxgl.accessToken = 'pk.eyJ1IjoiaWJlc29yYSIsImEiOiJjbTI5YWMxcjIwNDB0MmtyMTIzbXRmdmJjIn0.MZaG62HYHQckcXGVlM039A';
    const map = new mapboxgl.Map({
        container: 'map',
        zoom: 3,
        center: [7.5, 58],
        // Choose from Mapbox's core styles, or make your own style with Mapbox Studio
        style: 'mapbox://styles/mapbox/standard-satellite',
        antialias: true, // create the gl context with MSAA antialiasing, so custom layers are antialiased
        projection: 'mercator',
        hash: true, // #14.28/46.94721/8.71206,
    });

    // Add the terrain layer
    map.on('style.load', () => {
        map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
        });
        // add the DEM source as a terrain layer with exaggerated height
        map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.0 });
    });

    map.on('load', () => {
        fetch("drone.kml")
            .then(function (response) {
                return response.text();
            })
            .then(function (xml) {
              const featureCollection = kml(new DOMParser().parseFromString(xml, "text/xml"));
              const { route, mercatorRoute } = convertToMercator(featureCollection);
              const flatMercatorRoute = mercatorRoute.flat(Infinity);
              const attributes = createVertexAttributes(flatMercatorRoute);
              addCustomLayer(attributes, flatMercatorRoute.length);
              resetRouteData(route.flat(1));
              addKeyboardEvents();
            })
    })

    function convertToMercator(featureCollection) {
        const mercatorRoute = [];
        const route = featureCollection.features.map((feature) => {
            if (!feature.geometry) return [];
            if (feature.geometry.type !== 'LineString') return [];
            if (!feature.geometry.coordinates) return [];
            return feature.geometry.coordinates.map((coord) => {
                const mercatorCoordinates =  mapboxgl.MercatorCoordinate.fromLngLat({
                    lng: coord[0],
                    lat: coord[1],
                }, coord[2] || 0);
                mercatorRoute.push([mercatorCoordinates.x, mercatorCoordinates.y, mercatorCoordinates.z]);
                return [coord[0], coord[1], coord[2] || 0];
            });
        });
        return { route, mercatorRoute }
    }

    function createVertexAttributes(route) {
        const bytesPerVertex = 37 // 4 bytes per coordinate + 1 byte per normal direction + 4 per previous vertex coordinate + 4 per next vertex coordinate
        const verticesPerPoint = 2;
        const buffer = new ArrayBuffer(
          bytesPerVertex * verticesPerPoint * route.length,
        );
        
        const dv = new DataView(buffer);
        route.forEach((currentVertex, i) => {
            const vertexOffset = i * bytesPerVertex * verticesPerPoint;
            const previousVertex = route[i - 1] || route[i];
            const nextVertex = route[i + 1] || route[i];
            addVertex(dv, vertexOffset, currentVertex[0], currentVertex[1], currentVertex[2], true, previousVertex[0], previousVertex[1], previousVertex[2], nextVertex[0], nextVertex[1], nextVertex[2]);
            addVertex(dv, vertexOffset + bytesPerVertex, currentVertex[0], currentVertex[1], currentVertex[2], false, previousVertex[0], previousVertex[1], previousVertex[2], nextVertex[0], nextVertex[1], nextVertex[2]);
        });

        return buffer;
    }

    function addVertex(
        dv,
        vertexOffset,
        currentX, currentY, currentZ,
        normalDirection,
        previousX, previousY, previousZ,
        nextX, nextY, nextZ
    ) {
        dv.setFloat32(vertexOffset, currentX, true);
        dv.setFloat32(vertexOffset + 4, currentY, true);
        dv.setFloat32(vertexOffset + 8, currentZ, true);
        dv.setUint8(vertexOffset + 12, normalDirection ? 1 : 0);
        dv.setFloat32(vertexOffset + 13, previousX, true);
        dv.setFloat32(vertexOffset + 17, previousY, true);
        dv.setFloat32(vertexOffset + 21, previousZ, true);
        dv.setFloat32(vertexOffset + 25, nextX, true);
        dv.setFloat32(vertexOffset + 29, nextY, true);
        dv.setFloat32(vertexOffset + 33, nextZ, true);
    }

    function addCustomLayer(attributes, numPoints) {

        // create a custom style layer to implement the WebGL content
        const customLayer = {
            id: 'highlight',
            type: 'custom',
            renderingMode: '3d',

            // method called when the layer is added to the map
            // https://docs.mapbox.com/mapbox-gl-js/api/#styleimageinterface#onadd
            onAdd: function (map, gl) {
                // create GLSL source for vertex shader
                const vertexSource = `
                    uniform mat4 u_matrix;
                    uniform float aspectRatio;
                    uniform float thickness;
                    attribute vec3 a_pos;
                    attribute vec3 next;
                    attribute vec3 prev;
                    attribute bool positiveNormal;
                    void main() {
                        gl_Position = u_matrix * vec4(a_pos, 1.0);
                    }`;

                // create GLSL source for fragment shader
                const fragmentSource = `
                    void main() {
                        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                    }`;

                // create a vertex shader
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, vertexSource);
                gl.compileShader(vertexShader);

                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    const error = gl.getShaderInfoLog(vertexShader);
                    console.log(error);
                    throw new Error(`Could not compile vertex shader: ${error}`);
                }

                // create a fragment shader
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, fragmentSource);
                gl.compileShader(fragmentShader);

                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    const error = gl.getShaderInfoLog(fragmentShader);
                    console.log(error);
                    throw new Error(`Could not compile fragment shader: ${error}`);
                }

                // link the two shaders into a WebGL program
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    const error = gl.getProgramInfoLog(this.program);
                    console.log(error);
                    throw new Error(`Program failed to link: ${error}`);
                }

                this.aPos = gl.getAttribLocation(this.program, 'a_pos');

                // create and initialize a WebGLBuffer to store vertex and color data
                this.buffer = gl.createBuffer();
                this.elementNum = numPoints * 2;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(route),
                    gl.STATIC_DRAW
                );
            },

            // method fired on each animation frame
            // https://docs.mapbox.com/mapbox-gl-js/api/#map.event:render
            render: function (gl, matrix) {
                gl.useProgram(this.program);
                gl.uniformMatrix4fv(
                    gl.getUniformLocation(this.program, 'u_matrix'),
                    false,
                    matrix
                );
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.enableVertexAttribArray(this.aPos);
                gl.enableVertexAttribArray(this.normalDirection);
                gl.enableVertexAttribArray(this.previousVertex);
                gl.enableVertexAttribArray(this.nextVertex);
                gl.vertexAttribPointer(this.aPos, 3, gl.FLOAT, false, 37, 0);
                gl.vertexAttribPointer(this.normalDirection, 1, gl.UNSIGNED_BYTE, false, 37, 12);
                gl.vertexAttribPointer(this.previousVertex, 3, gl.FLOAT, false, 37, 13);
                gl.vertexAttribPointer(this.nextVertex, 3, gl.FLOAT, false, 37, 25);
                gl.drawArrays(gl.TRIANGLES, 0, this.elementNum);
            }
        };

        map.addLayer(customLayer);
    }

    const routeData = {
      lineString: undefined,
      routeDistance: undefined
    }

    const animationData = {
      secondsPerKm: 3,
      altitudeOffsetInMeters: 200,
      followAlongDistanceInKm: 0.2,
      durationInMillis: undefined,
      start: undefined,
      request: undefined,
      cameraPositions: undefined,
      isStoringCameraPositions: true,
      isPlaying: false
    }

    function resetRouteData(route) {
      routeData.lineString = turf.lineString(route);
      routeData.routeDistance = turf.lineDistance(routeData.lineString);
    }

    function resetAnimationData() {
        animationData.start = undefined;
        const secondsPerKm = 10.0;
        animationData.durationInMillis = routeData.routeDistance * animationData.secondsPerKm * 1000;
        animationData.isPlaying = false;
        animationData.isStoringCameraPositions = true;
        animationData.cameraPositions = [];
    }

    function addKeyboardEvents() {
        document.addEventListener('keypress', (e) => {
            if (e.code === "Space") toggleCameraAnimation();
        });
    }

    function toggleCameraAnimation() {
        if (!animationData.isPlaying) {
            resetAnimationData();
            animationData.request = window.requestAnimationFrame(nextFrame);
        }
        else {
            animationData.isPlaying = false;
            window.cancelAnimationFrame(animationData.request);
        }
    }

    function nextFrame(time) {
        if (!animationData.isPlaying) {
            animationData.isPlaying = true;
            animationData.start = time;
        }
        const { start, durationInMillis } = animationData;
        const phase = (time - start) / durationInMillis;
        if (phase > 1.0) {
          animationData.isPlaying = false;
          animationData.lastCameraPosition = undefined;
          return;
        }

        const lookAtWithAltitude = along(routeData.lineString, routeData.routeDistance * phase);

        animationData.cameraPositions.push(lookAtWithAltitude);
        if (animationData.isStoringCameraPositions) {
          const distance = turf.distance(
            turf.point(animationData.cameraPositions[0]),
            turf.point(lookAtWithAltitude)
          );
          animationData.isStoringCameraPositions = distance < animationData.followAlongDistanceInKm;
        } else {
          animationData.cameraPositions.shift();
        }

        const camera = map.getFreeCameraOptions();
        camera.position = mapboxgl.MercatorCoordinate.fromLngLat(
            {
                lng: animationData.cameraPositions[0][0],
                lat: animationData.cameraPositions[0][1]
            },
            animationData.altitudeOffsetInMeters + (animationData.cameraPositions[0][2] || 0)
        );

        // Why doesn't camera.lookAtPoint support altitude?
        camera.lookAtPoint(
            {
                lng: lookAtWithAltitude[0],
                lat: lookAtWithAltitude[1]
            }
        );

        map.setFreeCameraOptions(camera);

        animationData.request = window.requestAnimationFrame(nextFrame);
    }

    function along(lineString, distance) {
        // Unfortunately turf.along does not support coordinates with altitude so we implement our own
        // Using turf.along for the horizontal distance and then linear interpolation for the altitude
        const coords = lineString.geometry.coordinates;
        let travelled = 0;
        for (let i = 0; i < coords.length - 1; i++) {
          const segment = turf.lineString([coords[i], coords[i + 1]]);
          const segmentDistance = turf.length(segment, { units: 'kilometers' });
          if (travelled + segmentDistance >= distance) {
            const overshotDistance = distance - travelled;
            const finalCoords = turf.along(segment, overshotDistance, { units: 'kilometers' }).geometry.coordinates;
            const finalHeight = lerp(coords[i][2] || 0, coords[i + 1][2] || 0, overshotDistance / segmentDistance);
            return [finalCoords[0], finalCoords[1], finalHeight];
          }
          travelled += segmentDistance;
        }
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
</script>

</body>
</html>